<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>Web CPT</title>
  <style>
    :root{
      --bg:#000;
      --panel: rgba(255,255,255,0.10);
      --panelStroke: rgba(255,255,255,0.14);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --tap:#e53935;
      --tapText:#fff;
      --card: rgba(255,255,255,0.06);
      --cardStroke: rgba(255,255,255,0.10);
      --ok: rgba(70, 200, 120, 0.95);
      --bad: rgba(229,57,53,0.95);
      --chip: rgba(255,255,255,0.08);
      --chipStroke: rgba(255,255,255,0.12);
      --chipOn: rgba(229,57,53,0.22);
      --chipOnStroke: rgba(229,57,53,0.40);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html,body{ height:100%; margin:0; background:var(--bg); font-family: system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;}
    body{ overflow:hidden; color: var(--text); }

    .wrap{
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: env(safe-area-inset-top) 18px env(safe-area-inset-bottom) 18px;
    }
    .app{
      width:min(900px, 100%);
      display:flex;
      flex-direction:column;
      gap:14px;
      align-items:stretch;
    }

    .topStrip{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.88);
      font-weight: 900;
      font-size: 14px;
    }
    .topStrip .mut{ color: rgba(255,255,255,0.65); font-weight: 800; }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.10);
      font-size: 12px;
      font-weight: 900;
    }

    .panel{
      width:100%;
      aspect-ratio: 16 / 8;
      min-height: 300px;
      max-height: 420px;
      background: var(--panel);
      border: 1px solid var(--panelStroke);
      border-radius: 22px;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
      transition: border-color 120ms ease, box-shadow 120ms ease;
    }
    .panel.feedback-ok{
      border-color: rgba(70,200,120,0.85);
      box-shadow: 0 0 0 2px rgba(70,200,120,0.20) inset;
    }
    .panel.feedback-bad{
      border-color: rgba(229,57,53,0.85);
      box-shadow: 0 0 0 2px rgba(229,57,53,0.20) inset;
    }
    .panelInner{
      width: 70%;
      height: 70%;
      display:flex;
      align-items:center;
      justify-content:center;
      opacity: 0;
      transition: opacity 70ms linear;
      user-select:none;
      pointer-events:none;
    }
    .panelInner.show{ opacity: 1; }

    .tap{
      width:100%;
      height: 96px;
      background: var(--tap);
      color: var(--tapText);
      border:none;
      border-radius: 18px;
      font-weight: 900;
      font-size: 30px;
      letter-spacing: 1px;
      transform: translateZ(0);
      transition: transform 80ms ease, filter 80ms ease;
    }
    .tap:active{ transform: scale(0.985); filter: brightness(1.05); }
    .tap:disabled{ opacity:0.35; }

    .idleControls{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .hint{
      text-align:center;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.35;
    }
    .startRow{
      display:flex;
      gap:12px;
      justify-content:center;
      align-items:center;
    }

    .overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: env(safe-area-inset-top) 18px env(safe-area-inset-bottom) 18px;
      background: rgba(0,0,0,0.72);
      z-index: 50;
    }
    .overlay.show{ display:flex; }
    .modal{
      width:min(720px, 100%);
      background: rgba(20,20,20,0.92);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      padding: 18px;
      color: var(--text);
    }
    .modal h2{ margin:0 0 10px 0; font-size: 22px; }
    .modal p{
      margin:8px 0;
      color: var(--muted);
      line-height: 1.45;
      white-space: pre-line;
      font-size: 24px;
      font-weight: 850;
    }
    .modal .row{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:flex-end;
      margin-top: 14px;
    }
    .btn{
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.08);
      color: var(--text);
      font-weight: 900;
      font-size: 16px;
      transition: transform 80ms ease, filter 80ms ease;
    }
    .btn:active{ transform: scale(0.98); filter: brightness(1.05); }
    .btn.primary{
      background: rgba(229,57,53,0.92);
      border-color: rgba(229,57,53,0.92);
    }
    .btn:disabled{ opacity:0.45; }

    .sheet{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: env(safe-area-inset-top) 18px env(safe-area-inset-bottom) 18px;
      background: rgba(0,0,0,0.72);
      z-index: 55;
    }
    .sheet.show{ display:flex; }
    .sheet .modal{ width:min(760px, 100%); }
    .chips{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top: 10px;
    }
    .chip{
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--chipStroke);
      background: var(--chip);
      color: rgba(255,255,255,0.9);
      font-weight: 900;
      font-size: 14px;
      user-select:none;
      cursor:pointer;
      transition: transform 80ms ease, background 120ms ease, border-color 120ms ease, filter 80ms ease;
    }
    .chip:active{ transform: scale(0.98); filter: brightness(1.05); }
    .chip.on{
      background: var(--chipOn);
      border-color: var(--chipOnStroke);
    }

    .selectWrap{
      margin-top: 10px;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .ageSelect{
      width: min(320px, 100%);
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      font-weight: 900;
      font-size: 16px;
      outline: none;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }
    .ageSelect option{
      background: #111;
      color: rgba(255,255,255,0.92);
      font-weight: 800;
    }

    .statusLine{
      margin-top: 10px;
      font-size: 13px;
      font-weight: 900;
      color: rgba(255,255,255,0.8);
    }
    .statusLine.ok{ color: var(--ok); }
    .statusLine.bad{ color: var(--bad); }

    .results{
      position:fixed;
      inset:0;
      background:#0b0b0b;
      color:var(--text);
      display:none;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      z-index: 60;
    }
    .results.show{ display:block; }
    .results .inner{
      width:min(980px, 100%);
      margin: 0 auto;
      padding: env(safe-area-inset-top) 16px env(safe-area-inset-bottom) 22px 16px;
    }
    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      position: sticky;
      top: 0;
      padding: 10px 0;
      background: linear-gradient(#0b0b0b 80%, rgba(11,11,11,0));
      z-index: 5;
    }
    .topbar h1{ margin:0; font-size: 22px; }

    .topbarRight{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
    }

    .pill{
      display:inline-flex;
      gap:10px;
      align-items:center;
      font-weight: 900;
      font-size: 13px;
      color: rgba(255,255,255,0.85);
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.10);
    }

    .closeX{
      width: 38px;
      height: 38px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.88);
      font-weight: 1000;
      font-size: 18px;
      line-height: 1;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      transition: transform 80ms ease, filter 80ms ease;
    }
    .closeX:active{ transform: scale(0.98); filter: brightness(1.05); }

    .section{
      margin-top: 14px;
      padding: 14px;
      background: var(--card);
      border: 1px solid var(--cardStroke);
      border-radius: 14px;
    }
    .section h3{ margin: 0 0 10px 0; font-size: 18px; }
    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 8px 10px;
      font-size: 15px;
      color: rgba(255,255,255,0.85);
    }
    .kv div:nth-child(2n){
      text-align:right;
      color: rgba(255,255,255,0.92);
      font-weight: 900;
    }
    .muted{ color: var(--muted); font-size: 13px; line-height: 1.35; }

    .chartGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .chartCard{
      background: rgba(0,0,0,0.30);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 10px;
    }
    .chartHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      font-size: 13px;
      font-weight: 900;
      color: rgba(255,255,255,0.85);
      margin-bottom: 6px;
    }
    canvas{ width:100%; height: 96px; display:block; border-radius: 10px; background: rgba(255,255,255,0.04); }

    .tooltip{
      position: fixed;
      z-index: 80;
      pointer-events:none;
      display:none;
      background: rgba(0,0,0,0.72);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 10px;
      padding: 8px 10px;
      color: rgba(255,255,255,0.92);
      font-size: 12px;
      line-height: 1.25;
      white-space: pre-line;
      max-width: 240px;
    }
    .tooltip.show{ display:block; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="app">
      <div class="topStrip">
        <div>전체 남은 시간: <span id="totalRemain">-</span></div>
        <div class="badge"><span class="mut">상태</span> <span id="statusText">IDLE</span></div>
      </div>

      <div id="panel" class="panel">
        <div id="stimulus" class="panelInner"></div>
      </div>

      <button id="tapBtn" class="tap" disabled>TAP</button>

      <div id="idleControls" class="idleControls">
        <div class="hint" id="hint">
          Start 후에는 <b>빨간 TAP</b>만 누르세요 (단계 시작 때 규칙 안내가 뜹니다)
        </div>

        <div class="startRow">
          <button id="startBtn" class="btn primary">Start</button>
          <button id="openResultsBtn" class="btn" disabled>Results</button>
          <button id="resetBtn" class="btn">Reset</button>
        </div>
      </div>
    </div>
  </div>

  <div id="overlay" class="overlay">
    <div class="modal">
      <h2 id="ovTitle">규칙</h2>
      <p id="ovBody"></p>
      <p id="ovCountdown" style="font-weight:900;color:rgba(255,255,255,0.9)"></p>
      <div class="row">
        <button id="ovSkip" class="btn">바로 시작</button>
      </div>
    </div>
  </div>

  <div id="demoSheet" class="sheet">
    <div class="modal">
      <h2>성별 / 나이</h2>
      <p style="font-size:16px;font-weight:800;line-height:1.35">
        결과 확인을 누르면 데이터가 서버로 제출되고, 그 다음 결과 화면이 열립니다.
      </p>

      <div style="margin-top:12px;font-weight:900;color:rgba(255,255,255,0.88)">성별</div>
      <div class="chips" id="genderChips"></div>

      <div style="margin-top:14px;font-weight:900;color:rgba(255,255,255,0.88)">나이 (만)</div>
      <div class="selectWrap">
        <select id="ageSelect" class="ageSelect" aria-label="나이 선택"></select>
      </div>

      <div id="submitStatus" class="statusLine"></div>

      <div class="row" style="justify-content:space-between">
        <button id="cancelDemo" class="btn">취소</button>
        <button id="submitAndOpen" class="btn primary" disabled>결과 확인하기</button>
      </div>
    </div>
  </div>

  <div id="results" class="results">
    <div class="inner">
      <div class="topbar">
        <h1>Results</h1>
        <div class="topbarRight">
          <span id="thrPill" class="pill">RT rules: -</span>
          <button id="closeResults" class="closeX" aria-label="닫기" title="닫기">×</button>
        </div>
      </div>

      <div class="section">
        <h3>단계별 요약 (Core: 1~3단계만 표시)</h3>
        <div id="blockSummaries" class="muted">-</div>
      </div>

      <div class="section">
        <h3>Core 타임라인 4지표 차트 (15s bin)</h3>
        <div class="muted">터치/드래그하면 같은 시간대(x축)가 4개 차트에서 함께 움직입니다.</div>
        <div class="chartGrid" id="quadCharts"></div>
      </div>

      <div class="section">
        <h3>해설 참고용 정보</h3>
        <div class="muted">
          - Omission↑: 타겟 놓침(주의 이탈/각성 저하/지속주의 저하 가능)<br/>
          - Commission↑: 비타겟 반응(억제 실패/충동/규칙 유지 실패)<br/>
          - MeanRT↑: 처리속도 저하/조심모드/각성 저하 가능<br/>
          - RTV↑: 반응 일관성 붕괴(주의 변동/피로/압박 민감)<br/>
          - Anticipatory↑: 성급/예측반응 신호
        </div>
      </div>

      <div style="height:22px"></div>
    </div>
  </div>

  <div id="tooltip" class="tooltip"></div>

<script>
(() => {
  // =========================================================
  // Presigned URL 기반 S3 업로드
  // =========================================================
  async function getPresignedPutUrl(contentType){
    const res = await fetch("/api/get-presigned-url", {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(contentType ? { contentType } : {}),
    });
    const text = await res.text();
    let data = null;
    try { data = JSON.parse(text); } catch { data = { raw:text }; }
    if(!res.ok || !data?.url){
      throw new Error(data?.error || `PRESIGN_HTTP ${res.status}`);
    }
    return data; // { url, key }
  }

  async function putJsonToS3(presignedUrl, payload){
    const res = await fetch(presignedUrl, {
      method: "PUT",
      body: JSON.stringify(payload),
    });
    if(!res.ok){
      throw new Error(`S3_PUT_HTTP ${res.status}`);
    }
  }

  // =========================================================
  // ✅ New Config (9분 목표 유지: 60+120+120+180+60=540s)
  // =========================================================
  const CFG = {
    stimOnMs: 180,

    // block durations in seconds
    dur: { b0: 60, b1: 120, b2: 120, b3: 180, b4: 60 },

    instructionSec: 10,

    // ✅ fixed onset-to-onset ISI per block
    isiMs: { b0:1200, b1:900, b2:900, b3:1200, b4:900 },

    // ✅ response window per block (used for omission/late)
    winMs: { b0:900, b1:650, b2:650, b3:900, b4:650 },

    // anticipatory threshold
    anticipatoryMs: 150,

    // chart bin
    binSec: 15,

    // core validity (optional)
    invalid: { minTargets: 12, hitRateBelow: 0.20, commissionRateAbove: 0.60 },

    // block2/b3 target ratios (core)
    ratios: {
      coreB1_target: 0.30, // block1 (core speed-up) target ratio
      coreB2_target: 0.15, // block2 (core inhibition↑) target ratio
      // collapse probe block3 fixed ratios (4b)
      collapse_target: 0.20,
      collapse_lure: 0.20,
    },

    // collapse learning segment length (4a)
    collapseLearnTrials: 20,
  };

  // =========================================================
  // Helpers: block meta
  // =========================================================
  function blockMeta(block){
    // block: 0..4
    if(block===0) return { phase:"core",    ruleSetId:"B0_adapt_square_v1" };
    if(block===1) return { phase:"core",    ruleSetId:"B1_core_triangle_fast_v1" };
    if(block===2) return { phase:"core",    ruleSetId:"B2_core_triangle_inhibit_v1" };
    if(block===3) return { phase:"collapse",ruleSetId:"B3_nested_collapse_v1" };
    if(block===4) return { phase:"recovery",ruleSetId:"B4_recovery_triangle_v1" };
    return { phase:"unknown", ruleSetId:"unknown" };
  }
  function onsetToOnsetMs(block){
    if(block===0) return CFG.isiMs.b0;
    if(block===1) return CFG.isiMs.b1;
    if(block===2) return CFG.isiMs.b2;
    if(block===3) return CFG.isiMs.b3;
    if(block===4) return CFG.isiMs.b4;
    return 1000;
  }
  function responseWindowMs(block){
    if(block===0) return CFG.winMs.b0;
    if(block===1) return CFG.winMs.b1;
    if(block===2) return CFG.winMs.b2;
    if(block===3) return CFG.winMs.b3;
    if(block===4) return CFG.winMs.b4;
    return 900;
  }

  // =========================================================
  // State
  // =========================================================
  const State = {
    phase: "idle", // idle | instruction | running | finished
    block: null,   // 0..4
    blockStartTs: 0,
    blockTimerId: null,
    stimTimeoutId: null,
    nextStimTimeoutId: null,
    awaitingTrialId: null,
    trialIndexInBlock: 0,
    trials: [],
    hasAnyData: false,

    // demographics
    demo: { gender:null, age:null, submitted:false, submitKey:null },

    // total timer ui
    totalTimerId: null,

    // quality meta
    quality: { blurCount:0, visibilityChangeCount:0 }
  };

  // =========================================================
  // DOM
  // =========================================================
  const panelEl = document.getElementById("panel");
  const stimulusEl = document.getElementById("stimulus");
  const tapBtn = document.getElementById("tapBtn");
  const startBtn = document.getElementById("startBtn");
  const resetBtn = document.getElementById("resetBtn");
  const openResultsBtn = document.getElementById("openResultsBtn");
  const hintEl = document.getElementById("hint");
  const idleControls = document.getElementById("idleControls");

  const overlay = document.getElementById("overlay");
  const ovTitle = document.getElementById("ovTitle");
  const ovBody = document.getElementById("ovBody");
  const ovCountdown = document.getElementById("ovCountdown");
  const ovSkip = document.getElementById("ovSkip");

  const totalRemainEl = document.getElementById("totalRemain");
  const statusText = document.getElementById("statusText");

  const results = document.getElementById("results");
  const closeResults = document.getElementById("closeResults");
  const blockSummaries = document.getElementById("blockSummaries");
  const quadCharts = document.getElementById("quadCharts");
  const thrPill = document.getElementById("thrPill");
  const tooltip = document.getElementById("tooltip");

  // demo sheet
  const demoSheet = document.getElementById("demoSheet");
  const genderChips = document.getElementById("genderChips");
  const ageSelect = document.getElementById("ageSelect");
  const cancelDemo = document.getElementById("cancelDemo");
  const submitAndOpen = document.getElementById("submitAndOpen");
  const submitStatus = document.getElementById("submitStatus");

  document.addEventListener("gesturestart", (e)=>e.preventDefault());
  document.addEventListener("dblclick", (e)=>e.preventDefault());

  // quality signals
  window.addEventListener("blur", ()=>{ State.quality.blurCount += 1; });
  document.addEventListener("visibilitychange", ()=>{ State.quality.visibilityChangeCount += 1; });

  // =========================================================
  // Utils
  // =========================================================
  const nowMs = () => performance.now();
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const mean = (arr)=> arr.reduce((s,x)=>s+x,0)/arr.length;
  const std = (arr)=>{
    if(arr.length<2) return null;
    const m=mean(arr);
    const v=arr.reduce((s,x)=>s+(x-m)*(x-m),0)/(arr.length-1);
    return Math.sqrt(v);
  };

  function setPhase(p){
    State.phase = p;
    statusText.textContent = p.toUpperCase();
    if(p === "running" || p === "instruction"){
      idleControls.style.display = "none";
    } else {
      idleControls.style.display = "flex";
    }
  }

  const TOTAL_TEST_SEC =
    CFG.dur.b0 + CFG.dur.b1 + CFG.dur.b2 + CFG.dur.b3 + CFG.dur.b4;

  function formatRemain(sec){
    sec = Math.max(0, Math.ceil(sec));
    const m = Math.floor(sec/60);
    const s = sec % 60;
    return `${m}:${String(s).padStart(2,"0")}`;
  }

  function totalElapsedSec(){
    if(State.phase === "idle") return 0;
    if(State.phase === "finished") return TOTAL_TEST_SEC;

    const b = State.block ?? 0;

    let done = 0;
    if(b >= 1) done += CFG.dur.b0;
    if(b >= 2) done += CFG.dur.b1;
    if(b >= 3) done += CFG.dur.b2;
    if(b >= 4) done += CFG.dur.b3;

    if(State.phase === "running"){
      done += (nowMs() - State.blockStartTs)/1000;
    }
    return clamp(done, 0, TOTAL_TEST_SEC);
  }

  function startTotalTimer(){
    stopTotalTimer();
    State.totalTimerId = setInterval(()=>{
      const remain = TOTAL_TEST_SEC - totalElapsedSec();
      totalRemainEl.textContent = formatRemain(remain);
    }, 200);
  }
  function stopTotalTimer(){
    if(State.totalTimerId){ clearInterval(State.totalTimerId); State.totalTimerId=null; }
  }

  // =========================================================
  // Shapes (SVG)
  // =========================================================
  function svgShape(kind, opts={}) {
    const stroke = opts.stroke || "rgba(255,255,255,0.92)";
    const strokeW = opts.strokeW || 10;
    const fill = "none";
    const size = 260;
    const cx = size/2, cy = size/2;

    const header = `<svg width="100%" height="100%" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">`;
    const footer = `</svg>`;

    const circle = (r) =>
      `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${fill}" stroke="${stroke}" stroke-width="${strokeW}" />`;

    const square = (side) => {
      const x = cx - side/2;
      const y = cy - side/2;
      return `<rect x="${x}" y="${y}" width="${side}" height="${side}" rx="10" fill="${fill}" stroke="${stroke}" stroke-width="${strokeW}" />`;
    };

    const triangle = (radius) => {
      const p1 = [cx, cy - radius];
      const p2 = [cx - radius*0.866, cy + radius*0.5];
      const p3 = [cx + radius*0.866, cy + radius*0.5];
      return `<path d="M ${p1[0]} ${p1[1]} L ${p2[0]} ${p2[1]} L ${p3[0]} ${p3[1]} Z"
        fill="${fill}" stroke="${stroke}" stroke-width="${strokeW}" stroke-linejoin="round" />`;
    };

    function drawBasic(k, scale=1.0){
      if(k==="circle") return circle(80*scale);
      if(k==="square") return square(160*scale);
      if(k==="triangle") return triangle(100*scale);
      return "";
    }

    if(kind==="circle") return header + drawBasic("circle",1.0) + footer;
    if(kind==="square") return header + drawBasic("square",1.0) + footer;
    if(kind==="triangle") return header + drawBasic("triangle",1.0) + footer;

    if(kind==="compound") {
      const outer = opts.outer;
      const inner = opts.inner;
      return header
        + drawBasic(outer, 1.0)
        + `<g opacity="0.95">` + drawBasic(inner, 0.55) + `</g>`
        + footer;
    }
    return header + footer;
  }

  function showStimulus(svg) {
    stimulusEl.innerHTML = svg;
    stimulusEl.classList.add("show");
  }
  function hideStimulus() {
    stimulusEl.classList.remove("show");
    stimulusEl.innerHTML = "";
  }

  // =========================================================
  // Instruction texts
  // =========================================================
  function stageNameFromBlock(block){
    return `${block + 1}단계`;
  }

  function blockRuleText(block) {
    switch(block){
      case 0:
        return `${stageNameFromBlock(block)} (약 1분)\n세모(△) / 네모(□)\n네모(□)일 때만 TAP`;
      case 1:
        return `${stageNameFromBlock(block)} (약 2분)\n동그라미(○) / 세모(△) / 네모(□)\n세모(△)일 때만 TAP\n(속도 ↑)`;
      case 2:
        return `${stageNameFromBlock(block)} (약 2분)\n동그라미(○) / 세모(△) / 네모(□)\n세모(△)일 때만 TAP\n(속도 유지, 타겟 희소 ↑)`;
      case 3:
        return `${stageNameFromBlock(block)} (약 3분)\n복합도형(중첩) 중\n'동그라미(○) 안에 네모(□)'일 때만 TAP\n※ 초반은 연습(피드백 ON), 이후는 피드백 OFF`;
      case 4:
        return `${stageNameFromBlock(block)} (쿨다운, 약 1분)\n동그라미(○) / 세모(△) / 네모(□)\n세모(△)일 때만 TAP`;
      default:
        return "";
    }
  }

  // =========================================================
  // Stimulus generation
  // =========================================================
  function weightedPick(items){ // [{v, w}]
    const total = items.reduce((s,x)=>s+x.w,0);
    let r = Math.random()*total;
    for(const it of items){
      r -= it.w;
      if(r <= 0) return it.v;
    }
    return items[items.length-1].v;
  }

  function makeStimulus(block){
    const C = "circle", T = "triangle", S = "square";

    // Blocks 1/2/4: 3 shapes with controlled target ratio for triangle
    function makeCoreTriangle(targetRatio){
      const nonRatio = (1 - targetRatio) / 2;
      const pick = weightedPick([
        { v:T, w: targetRatio },
        { v:C, w: nonRatio },
        { v:S, w: nonRatio },
      ]);
      const isTarget = (pick===T);
      return { stim:{kind:"basic",shape:pick}, isTarget, targetDesc:"triangle", renderSvg: svgShape(pick) };
    }

    if(block===0){
      // Adaptation: triangle/square, target square (roughly 50/50)
      const pick = weightedPick([{v:T,w:0.5},{v:S,w:0.5}]);
      const isTarget = (pick===S);
      return { stim:{kind:"basic",shape:pick}, isTarget, targetDesc:"square", renderSvg: svgShape(pick) };
    }

    if(block===1){
      return makeCoreTriangle(CFG.ratios.coreB1_target);
    }

    if(block===2){
      return makeCoreTriangle(CFG.ratios.coreB2_target);
    }

    if(block===3){
      // Collapse probe: nested 6 combos with fixed target/lure ratios in 4b
      const options = [
        { outer:C, inner:S, tag:"target" }, // circle>square target
        { outer:C, inner:T, tag:"lure"   }, // circle>triangle lure
        { outer:S, inner:C, tag:"other"  },
        { outer:S, inner:T, tag:"other"  },
        { outer:T, inner:C, tag:"other"  },
        { outer:T, inner:S, tag:"other"  },
      ];

      const idxInBlock = State.trialIndexInBlock + 1; // presentStimulus increments before create trial
      const isLearn = (idxInBlock <= CFG.collapseLearnTrials); // 4a
      let pick;

      if(isLearn){
        // 4a: slightly easier distribution for learning (more target/lure)
        pick = weightedPick([
          { v: options[0], w: 0.30 },
          { v: options[1], w: 0.20 },
          { v: options[2], w: 0.125 },
          { v: options[3], w: 0.125 },
          { v: options[4], w: 0.125 },
          { v: options[5], w: 0.125 },
        ]);
      } else {
        // 4b: fixed target 20%, lure 20%, others 60% evenly
        pick = weightedPick([
          { v: options[0], w: CFG.ratios.collapse_target },
          { v: options[1], w: CFG.ratios.collapse_lure },
          { v: options[2], w: 0.15 },
          { v: options[3], w: 0.15 },
          { v: options[4], w: 0.15 },
          { v: options[5], w: 0.15 },
        ]);
      }

      const isTarget = (pick.tag === "target");
      const isLure = (pick.tag === "lure");
      return {
        stim: { kind:"compound", outer: pick.outer, inner: pick.inner, tag: pick.tag },
        isTarget,
        isLure,
        targetDesc: "circle_outer+square_inner",
        renderSvg: svgShape("compound", { outer: pick.outer, inner: pick.inner })
      };
    }

    if(block===4){
      // Recovery: same as block1 (triangle among 3 shapes, fast)
      return makeCoreTriangle(CFG.ratios.coreB1_target);
    }
  }

  // =========================================================
  // Trial record
  // =========================================================
  function newTrial(block, trialIndex, stimPack){
    const meta = blockMeta(block);
    const win = responseWindowMs(block);
    const isi = onsetToOnsetMs(block);
    const isCollapse = (meta.phase === "collapse");
    const subBlock = isCollapse
      ? (trialIndex <= CFG.collapseLearnTrials ? "B4a" : "B4b")
      : null;

    return {
      id: (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now())+"-"+Math.random()),
      block,
      phase: meta.phase,
      ruleSetId: meta.ruleSetId,
      subBlock, // B4a/B4b for collapse only

      params: {
        onsetToOnsetMs: isi,
        responseWindowMs: win,
        ratios: (block===3)
          ? { target: CFG.ratios.collapse_target, lure: CFG.ratios.collapse_lure }
          : (block===1 || block===4)
            ? { target: CFG.ratios.coreB1_target }
            : (block===2)
              ? { target: CFG.ratios.coreB2_target }
              : null
      },

      trialIndex,
      presentedAtMs: nowMs(),
      blockElapsedSec: 0,
      stim: stimPack.stim,
      isTarget: !!stimPack.isTarget,
      isLure: !!stimPack.isLure,
      targetDesc: stimPack.targetDesc,

      responseWindowMs: win,

      tappedAtMs: null,
      rtMs: null,

      isHit: false,
      isCommission: false,
      isOmission: false,
      isAnticipatory: false,

      extraTapCount: 0,
      extraTapRts: [],

      // for collapse learning feedback: record whether feedback was shown
      feedbackShown: false,
      feedbackOk: null,
    };
  }

  // =========================================================
  // Flow control
  // =========================================================
  function stopAllTimers(){
    if(State.blockTimerId) { clearInterval(State.blockTimerId); State.blockTimerId=null; }
    if(State.stimTimeoutId){ clearTimeout(State.stimTimeoutId); State.stimTimeoutId=null; }
    if(State.nextStimTimeoutId){ clearTimeout(State.nextStimTimeoutId); State.nextStimTimeoutId=null; }
  }

  function resetAll(){
    stopAllTimers();
    stopTotalTimer();
    hideStimulus();

    overlay.classList.remove("show");
    demoSheet.classList.remove("show");
    results.classList.remove("show");
    hideTooltip();

    setPhase("idle");
    State.block=null;
    State.blockStartTs=0;
    State.awaitingTrialId=null;
    State.trialIndexInBlock=0;
    State.trials=[];
    State.hasAnyData=false;
    State.demo = { gender:null, age:null, submitted:false, submitKey:null };
    State.quality = { blurCount:0, visibilityChangeCount:0 };

    tapBtn.disabled=true;
    openResultsBtn.disabled=true;

    totalRemainEl.textContent = formatRemain(TOTAL_TEST_SEC);
    hintEl.style.display="block";
    hintEl.innerHTML = `Start 후에는 <b>빨간 TAP</b>만 누르세요 (단계 시작 때 규칙 안내가 뜹니다)`;
  }

  function startSequence(){
    resetAll();
    setPhase("instruction");
    State.block=0;
    startTotalTimer();
    showInstruction(0, ()=> startBlock(0));
  }

  function showInstruction(block, onDone){
    overlay.classList.add("show");
    ovTitle.textContent = `${stageNameFromBlock(block)} 안내`;
    ovBody.textContent = blockRuleText(block);

    let remain = CFG.instructionSec;
    ovCountdown.textContent = `시작까지 ${remain}초`;
    const tick = setInterval(()=>{
      remain -= 1;
      ovCountdown.textContent = `시작까지 ${remain}초`;
      if(remain<=0){
        clearInterval(tick);
        overlay.classList.remove("show");
        onDone();
      }
    }, 1000);

    ovSkip.onclick = () => {
      clearInterval(tick);
      overlay.classList.remove("show");
      onDone();
    };
  }

  function startBlock(block){
    stopAllTimers();
    hideStimulus();
    panelEl.classList.remove("feedback-ok","feedback-bad");

    setPhase("running");
    State.block = block;
    State.blockStartTs = nowMs();
    State.awaitingTrialId = null;
    State.trialIndexInBlock = 0;

    tapBtn.disabled=false;
    hintEl.style.display="none";

    const durSec = blockDurSec(block);
    State.blockTimerId = setInterval(()=>{
      const elapsed = (nowMs() - State.blockStartTs)/1000;
      if(elapsed >= durSec){
        clearInterval(State.blockTimerId);
        State.blockTimerId=null;
        finishBlock(block);
      }
    }, 200);

    scheduleNextStimulus(220);
  }

  function blockDurSec(block){
    if(block===0) return CFG.dur.b0;
    if(block===1) return CFG.dur.b1;
    if(block===2) return CFG.dur.b2;
    if(block===3) return CFG.dur.b3;
    if(block===4) return CFG.dur.b4;
    return 60;
  }

  function scheduleNextStimulus(delayMs){
    if(State.nextStimTimeoutId) clearTimeout(State.nextStimTimeoutId);
    State.nextStimTimeoutId = setTimeout(()=> presentStimulus(), delayMs);
  }

  function presentStimulus(){
    if(State.phase!=="running") return;
    const block = State.block;
    const durSec = blockDurSec(block);
    const elapsedSec = (nowMs() - State.blockStartTs)/1000;

    const stimPack = makeStimulus(block);

    State.trialIndexInBlock += 1;

    const t = newTrial(block, State.trialIndexInBlock, stimPack);
    t.blockElapsedSec = elapsedSec;

    State.trials.push(t);
    State.hasAnyData = true;
    openResultsBtn.disabled = false;

    State.awaitingTrialId = t.id;

    showStimulus(stimPack.renderSvg);
    State.stimTimeoutId = setTimeout(()=>{ hideStimulus(); }, CFG.stimOnMs);

    // finalize omission after response window
    setTimeout(()=> finalizeOmissionIfNeeded(t.id), t.responseWindowMs);

    // next onset scheduled with fixed onset-to-onset
    const isi = onsetToOnsetMs(block);
    scheduleNextStimulus(isi);
  }

  function finishBlock(block){
    stopAllTimers();
    hideStimulus();
    tapBtn.disabled=true;
    panelEl.classList.remove("feedback-ok","feedback-bad");

    if(block < 4){
      const next = block + 1;
      setPhase("instruction");
      State.block = next;
      showInstruction(next, ()=> startBlock(next));
    } else {
      setPhase("finished");
      hintEl.style.display="block";
      hintEl.innerHTML = `완료 ✅ Results에서 확인`;
      openResultsBtn.disabled = false;
      stopTotalTimer();
      totalRemainEl.textContent = formatRemain(0);
    }
  }

  // =========================================================
  // Feedback helper for collapse learning segment (B4a)
  // =========================================================
  function flashFeedback(ok){
    panelEl.classList.remove("feedback-ok","feedback-bad");
    panelEl.classList.add(ok ? "feedback-ok" : "feedback-bad");
    setTimeout(()=> panelEl.classList.remove("feedback-ok","feedback-bad"), 120);
  }

  // =========================================================
  // Tap handling
  // =========================================================
  function handleTap(){
    if(State.phase!=="running") return;
    if(!State.awaitingTrialId) return;

    const id = State.awaitingTrialId;
    const idx = State.trials.findIndex(x=>x.id===id);
    if(idx<0) return;

    const t = State.trials[idx];
    const rt = nowMs() - t.presentedAtMs;

    if(t.tappedAtMs !== null){
      t.extraTapCount += 1;
      t.extraTapRts.push(rt);
      return;
    }

    t.tappedAtMs = nowMs();
    t.rtMs = rt;

    if(rt < CFG.anticipatoryMs){
      t.isAnticipatory = true;
      // anticipatory counts as commission if nontarget (keep original spirit)
      if(!t.isTarget) t.isCommission = true;
      // feedback (learning segment only)
      if(t.phase==="collapse" && t.subBlock==="B4a"){
        t.feedbackShown = true;
        t.feedbackOk = false;
        flashFeedback(false);
      }
      return;
    }

    // too late => treat as omission for target, commission for nontarget
    if(rt > t.responseWindowMs){
      if(t.isTarget) t.isOmission = true;
      else t.isCommission = true;

      if(t.phase==="collapse" && t.subBlock==="B4a"){
        t.feedbackShown = true;
        t.feedbackOk = false;
        flashFeedback(false);
      }
      return;
    }

    // within window
    if(t.isTarget){
      t.isHit = true;
      if(t.phase==="collapse" && t.subBlock==="B4a"){
        t.feedbackShown = true;
        t.feedbackOk = true;
        flashFeedback(true);
      }
    } else {
      t.isCommission = true;
      if(t.phase==="collapse" && t.subBlock==="B4a"){
        t.feedbackShown = true;
        t.feedbackOk = false;
        flashFeedback(false);
      }
    }
  }

  function finalizeOmissionIfNeeded(trialId){
    const idx = State.trials.findIndex(x=>x.id===trialId);
    if(idx<0) return;
    const t = State.trials[idx];
    if(t.tappedAtMs===null && t.isTarget){
      t.isOmission = true;
      if(t.phase==="collapse" && t.subBlock==="B4a"){
        t.feedbackShown = true;
        t.feedbackOk = false;
        flashFeedback(false);
      }
    }
  }

  // =========================================================
  // Results summaries (CORE ONLY for user)
  // =========================================================
  function summarizeBlock(block){
    const ts = State.trials.filter(t=>t.block===block);
    const total = ts.length;
    const targets = ts.filter(t=>t.isTarget).length;
    const nontargets = total - targets;

    const hits = ts.filter(t=>t.isHit).length;
    const omissions = ts.filter(t=>t.isOmission).length;
    const commissions = ts.filter(t=>t.isCommission).length;
    const anticip = ts.filter(t=>t.isAnticipatory).length;

    const validRTs = ts
      .filter(t=>t.isHit && !t.isAnticipatory && typeof t.rtMs==="number")
      .map(t=>t.rtMs);

    const m = (validRTs.length ? mean(validRTs) : null);
    const sd = std(validRTs);
    const rtv = (m && sd && m>0) ? (sd/m) : null;

    const hitRate = targets ? hits/targets : null;
    const omissionRate = targets ? omissions/targets : 0;
    const commissionRate = nontargets ? commissions/nontargets : 0;
    const anticipRate = total ? anticip/total : 0;

    return {
      block, total, targets, nontargets,
      hits, omissions, commissions, anticip,
      hitRate, omissionRate, commissionRate,
      meanRT: m, rtv,
      anticipRate,
      validRTN: validRTs.length
    };
  }

  function invalidState(sum){
    if(sum.targets < CFG.invalid.minTargets) return "insufficient";
    if(sum.hitRate !== null && sum.hitRate < CFG.invalid.hitRateBelow) return "invalid";
    if(sum.commissionRate > CFG.invalid.commissionRateAbove) return "invalid";
    return "valid";
  }

  function blockOffsetSec(block){
    // offsets for core blocks 0..2 only
    if(block===0) return 0;
    if(block===1) return CFG.dur.b0;
    if(block===2) return CFG.dur.b0 + CFG.dur.b1;
    return 0;
  }

  function summarizeGlobalBins(binSec){
    const blocks = [0,1,2]; // ✅ core only
    const all = State.trials.filter(t=>blocks.includes(t.block));
    if(!all.length) return [];

    const invalidBlocks = new Set();
    for(const b of blocks){
      const s = summarizeBlock(b);
      if(invalidState(s)==="invalid") invalidBlocks.add(b);
    }
    const valid = all.filter(t=>!invalidBlocks.has(t.block));
    if(!valid.length) return [];

    const sorted = [...valid].sort((a,b)=>a.presentedAtMs - b.presentedAtMs);
    const idToGi = new Map();
    sorted.forEach((t,i)=>idToGi.set(t.id, i+1));

    const gts = sorted.map(t=>{
      const gt = blockOffsetSec(t.block) + t.blockElapsedSec;
      return { gt, t, gi: idToGi.get(t.id) };
    });

    const maxT = Math.max(...gts.map(x=>x.gt));
    const binCount = Math.ceil(maxT / binSec);
    const out=[];

    for(let bi=0; bi<binCount; bi++){
      const start = bi*binSec, end=(bi+1)*binSec;
      const chunk = gts.filter(x=>x.gt>=start && x.gt<end);
      if(!chunk.length) continue;

      const trials = chunk.map(x=>x.t);
      const total = trials.length;
      const targets = trials.filter(t=>t.isTarget).length;
      const nontargets = total-targets;
      const omissions = trials.filter(t=>t.isOmission).length;
      const commissions = trials.filter(t=>t.isCommission).length;

      const validRTs = trials
        .filter(t=>t.isHit && !t.isAnticipatory && typeof t.rtMs==="number")
        .map(t=>t.rtMs);

      const m = validRTs.length ? mean(validRTs) : null;
      const sd = std(validRTs);
      const rtv = (m && sd && m>0) ? (sd/m) : null;

      const gis = chunk.map(x=>x.gi).sort((a,b)=>a-b);
      const center = (start+end)/2;
      const nearest = chunk.reduce((best,cur)=>{
        if(!best) return cur;
        return (Math.abs(cur.gt-center) < Math.abs(best.gt-center)) ? cur : best;
      }, null);

      out.push({
        startSec: start, endSec: end,
        meanRT: m,
        rtv: rtv,
        omissionRate: targets? omissions/targets : null,
        commissionRate: nontargets? commissions/nontargets : null,
        trialIndexMin: gis[0] ?? null,
        trialIndexMax: gis[gis.length-1] ?? null,
        nearestTrialIndex: nearest ? nearest.gi : null
      });
    }
    return out;
  }

  // =========================================================
  // Charts: shared crosshair (unchanged)
  // =========================================================
  const ChartHub = {
    gbins: [],
    charts: [],
    activeIdx: null,
    isDragging: false,
  };

  function renderResults(){
    thrPill.textContent = `RT rules: anticipatory < ${CFG.anticipatoryMs}ms | omission window = per-block`;

    const blocks = [0,1,2]; // ✅ core only
    let html = "";
    for(const b of blocks){
      const s = summarizeBlock(b);
      const inv = invalidState(s);

      const tag = inv==="invalid" ? `<span class="pill" style="background:rgba(229,57,53,0.18);border-color:rgba(229,57,53,0.22)">NULL</span>`
                : inv==="insufficient" ? `<span class="pill" style="background:rgba(180,180,180,0.12)">N/A</span>`
                : `<span class="pill">OK</span>`;

      const fmt = (x, d=3)=> (x===null || Number.isNaN(x)) ? "N/A" : x.toFixed(d);
      const fmtMs = (x)=> (x===null) ? "N/A" : `${x.toFixed(1)} ms`;
      const showNull = (inv==="invalid");

      html += `
        <div class="section" style="margin-top:12px">
          <h3>${stageNameFromBlock(b)} ${tag}</h3>
          <div class="kv">
            <div>Trials</div><div>${s.total}</div>
            <div>Targets / NonTargets</div><div>${s.targets} / ${s.nontargets}</div>
            <div>Hit rate</div><div>${s.hitRate===null ? "N/A" : fmt(s.hitRate,3)}</div>
            <div>Omission rate</div><div>${showNull ? "NULL" : fmt(s.omissionRate,3)}</div>
            <div>Commission rate</div><div>${showNull ? "NULL" : fmt(s.commissionRate,3)}</div>
            <div>Mean RT</div><div>${showNull ? "NULL" : fmtMs(s.meanRT)}</div>
            <div>RTV (SD/Mean)</div><div>${showNull ? "NULL" : (s.rtv===null ? "N/A" : fmt(s.rtv,3))}</div>
            <div>Anticipatory rate</div><div>${showNull ? "NULL" : fmt(s.anticipRate,3)}</div>
            <div>Valid RT N</div><div>${s.validRTN}</div>
          </div>
        </div>
      `;
    }
    blockSummaries.innerHTML = html || "-";

    const gbins = summarizeGlobalBins(CFG.binSec);
    quadCharts.innerHTML = "";
    ChartHub.gbins = gbins;
    ChartHub.charts = [];
    ChartHub.activeIdx = null;
    ChartHub.isDragging = false;

    if(gbins.length < 2){
      quadCharts.innerHTML = `<div class="muted" style="margin-top:10px">N/A (유효한 bin이 부족)</div>`;
      return;
    }

    const panels = [
      { key:"meanRT",        title:"Mean RT (ms)",      format:(v)=>v.toFixed(0) },
      { key:"rtv",           title:"RTV (SD/Mean)",     format:(v)=>v.toFixed(2) },
      { key:"omissionRate",  title:"Omission rate",     format:(v)=>v.toFixed(2) },
      { key:"commissionRate",title:"Commission rate",  format:(v)=>v.toFixed(2) },
    ];

    for(const p of panels){
      const card = document.createElement("div");
      card.className = "chartCard";
      card.innerHTML = `
        <div class="chartHead">
          <div>${p.title}</div>
          <div style="color:rgba(255,255,255,0.65);font-weight:900">touch/drag</div>
        </div>
        <canvas></canvas>
      `;
      quadCharts.appendChild(card);

      const canvas = card.querySelector("canvas");
      const values = gbins.map(b=>b[p.key]);

      ChartHub.charts.push({ canvas, key:p.key, fmt:p.format, values });

      drawLineChart(canvas, values, gbins, p.format, null);
      attachSharedCrosshair(canvas);
    }
  }

  function drawLineChart(canvas, values, gbins, fmt, activeIdx){
    const dpr = window.devicePixelRatio || 1;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    canvas.width = Math.floor(w*dpr);
    canvas.height = Math.floor(h*dpr);

    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);

    const vs = values.filter(v => typeof v==="number" && !Number.isNaN(v));
    ctx.clearRect(0,0,w,h);
    if(vs.length < 2){
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.font = "900 12px system-ui";
      ctx.fillText("N/A", 10, 18);
      return;
    }

    let vmin = Math.min(...vs);
    let vmax = Math.max(...vs);
    if(vmin === vmax){ vmin -= 1e-6; vmax += 1e-6; }

    const pad = 10;
    const ix = (i)=> pad + (w-2*pad) * (i/(gbins.length-1));
    const iy = (v)=> {
      const t = (v - vmin) / (vmax - vmin);
      return (h-pad) - (h-2*pad) * clamp(t,0,1);
    };

    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;
    for(let r=0;r<=3;r++){
      const y = pad + (h-2*pad)*(r/3);
      ctx.beginPath(); ctx.moveTo(pad,y); ctx.lineTo(w-pad,y); ctx.stroke();
    }
    for(let c=0;c<=4;c++){
      const x = pad + (w-2*pad)*(c/4);
      ctx.beginPath(); ctx.moveTo(x,pad); ctx.lineTo(x,h-pad); ctx.stroke();
    }

    ctx.strokeStyle = "rgba(255,255,255,0.90)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    let started=false;
    for(let i=0;i<gbins.length;i++){
      const v = values[i];
      if(typeof v!=="number" || Number.isNaN(v)) continue;
      const x = ix(i), y = iy(v);
      if(!started){ ctx.moveTo(x,y); started=true; }
      else ctx.lineTo(x,y);
    }
    ctx.stroke();

    for(let i=gbins.length-1;i>=0;i--){
      const v = values[i];
      if(typeof v==="number" && !Number.isNaN(v)){
        const x=ix(i), y=iy(v);
        ctx.fillStyle="rgba(255,255,255,0.95)";
        ctx.beginPath(); ctx.arc(x,y,3.2,0,Math.PI*2); ctx.fill();
        break;
      }
    }

    if(typeof activeIdx === "number"){
      const idx = clamp(activeIdx, 0, gbins.length-1);
      const cx = ix(idx);
      ctx.strokeStyle="rgba(255,255,255,0.35)";
      ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(cx, pad); ctx.lineTo(cx, h-pad); ctx.stroke();
    }
  }

  function positionTooltip(clientX, clientY){
    tooltip.style.left = `${Math.min(clientX+14, window.innerWidth-260)}px`;
    tooltip.style.top  = `${Math.min(clientY+14, window.innerHeight-140)}px`;
    tooltip.classList.add("show");
  }

  function hideTooltip(){
    tooltip.classList.remove("show");
  }

  function setSharedActiveIdx(idx, clientX, clientY){
    if(!ChartHub.gbins.length) return;

    const gbins = ChartHub.gbins;
    ChartHub.activeIdx = clamp(idx, 0, gbins.length-1);

    for(const ch of ChartHub.charts){
      drawLineChart(ch.canvas, ch.values, gbins, ch.fmt, ChartHub.activeIdx);
    }
    positionTooltip(clientX, clientY);
  }

  function attachSharedCrosshair(canvas){
    const getIdxFromClientX = (clientX)=>{
      const rect = canvas.getBoundingClientRect();
      const x = clamp(clientX - rect.left, 0, rect.width);
      const idx = Math.round((x/Math.max(rect.width,1)) * (ChartHub.gbins.length-1));
      return idx;
    };

    const handler = (p, sourceCanvas)=>{
      const idx = getIdxFromClientX(p.clientX);
      ChartHub.isDragging = true;

      setSharedActiveIdx(idx, p.clientX, p.clientY);

      const gb = ChartHub.gbins[clamp(idx,0,ChartHub.gbins.length-1)];
      const ch = ChartHub.charts.find(x=>x.canvas===sourceCanvas);
      const v = ch ? gb[ch.key] : null;
      const valText = (typeof v==="number" && !Number.isNaN(v)) ? ch.fmt(v) : "NA";
      const range = (gb.trialIndexMin && gb.trialIndexMax) ? `Trials #${gb.trialIndexMin}–#${gb.trialIndexMax}` : `Trials NA`;
      const nearest = (gb.nearestTrialIndex) ? `Nearest trial: #${gb.nearestTrialIndex}` : `Nearest trial: NA`;

      tooltip.textContent =
        `t=${gb.startSec}–${gb.endSec}s (bin ${idx+1})\n${range}\n${nearest}\nValue: ${valText}`;
    };

    const onMove = (e) => {
      const p = (e.touches && e.touches[0]) ? e.touches[0] : e;
      handler(p, canvas);
    };

    const onEnd = () => {
      ChartHub.isDragging = false;
      hideTooltip();
      ChartHub.activeIdx = null;
      for(const ch of ChartHub.charts){
        drawLineChart(ch.canvas, ch.values, ChartHub.gbins, ch.fmt, null);
      }
    };

    canvas.addEventListener("pointerdown", onMove, {passive:true});
    canvas.addEventListener("pointermove", onMove, {passive:true});
    canvas.addEventListener("pointerup", onEnd, {passive:true});
    canvas.addEventListener("pointercancel", onEnd, {passive:true});
    canvas.addEventListener("touchstart", onMove, {passive:true});
    canvas.addEventListener("touchmove", onMove, {passive:true});
    canvas.addEventListener("touchend", onEnd, {passive:true});
  }

  // =========================================================
  // Submission payload (includes labeled trials + block meta)
  // =========================================================
  function buildBlocksMeta(){
    const blocks = [0,1,2,3,4];
    return blocks.map(b=>{
      const meta = blockMeta(b);
      return {
        block_id: b,
        phase: meta.phase,
        ruleSetId: meta.ruleSetId,
        durationSec: blockDurSec(b),
        params: {
          onsetToOnsetMs: onsetToOnsetMs(b),
          responseWindowMs: responseWindowMs(b),
          ratios: (b===3)
            ? { target: CFG.ratios.collapse_target, lure: CFG.ratios.collapse_lure, learnTrials: CFG.collapseLearnTrials }
            : (b===1 || b===4)
              ? { target: CFG.ratios.coreB1_target }
              : (b===2)
                ? { target: CFG.ratios.coreB2_target }
                : null
        }
      };
    });
  }

  function buildSummary(){
    const blocks = [0,1,2,3,4];
    const perBlock = {};
    for(const b of blocks){
      perBlock["b"+b] = summarizeBlock(b);
    }
    const globalBins = summarizeGlobalBins(CFG.binSec); // core-only
    return { perBlock, globalBins };
  }

  async function submitToServer(){
    const payload = {
      meta: {
        submittedAt: new Date().toISOString(),
        userAgent: navigator.userAgent,
        lang: navigator.language,
        tz: Intl.DateTimeFormat().resolvedOptions().timeZone || null,
        testVersion: "cpt_web_v2_core+collapse",
      },
      demographics: { ...State.demo },
      quality: { ...State.quality },
      cfg: CFG,
      blocks: buildBlocksMeta(),
      trials: State.trials,
      summary: buildSummary(),
    };

    const { url, key } = await getPresignedPutUrl();
    await putJsonToS3(url, payload);

    return { ok:true, key };
  }

  // =========================================================
  // Demo UI
  // =========================================================
  const GENDERS = [
    { label:"남성", value:"male" },
    { label:"여성", value:"female" },
  ];

  function renderChips(container, items, onPick){
    container.innerHTML = "";
    for(const it of items){
      const el = document.createElement("div");
      el.className = "chip";
      el.textContent = it.label;
      el.onclick = () => onPick(it.value);
      container.appendChild(el);
    }
  }

  function setChipOn(container, value){
    [...container.querySelectorAll(".chip")].forEach((el, i)=>{
      const v = GENDERS[i].value;
      el.classList.toggle("on", v===value);
    });
  }

  function renderAgeSelect(minAge, maxAge){
    ageSelect.innerHTML = "";

    const ph = document.createElement("option");
    ph.value = "";
    ph.textContent = "나이를 선택";
    ph.disabled = true;
    ph.selected = true;
    ageSelect.appendChild(ph);

    for(let a=minAge; a<=maxAge; a++){
      const opt = document.createElement("option");
      opt.value = String(a);
      opt.textContent = String(a);
      ageSelect.appendChild(opt);
    }
  }

  function updateSubmitButton(){
    const ok = !!State.demo.gender && (State.demo.age !== null && State.demo.age !== undefined && State.demo.age !== "");
    submitAndOpen.disabled = !ok;
  }

  function openDemoSheet(){
    submitStatus.textContent = "";
    submitStatus.className = "statusLine";
    demoSheet.classList.add("show");
    updateSubmitButton();
  }
  function closeDemoSheet(){
    demoSheet.classList.remove("show");
  }

  // =========================================================
  // Events
  // =========================================================
  tapBtn.addEventListener("pointerdown", (e)=>{ e.preventDefault(); handleTap(); }, {passive:false});
  tapBtn.addEventListener("touchstart",  (e)=>{ e.preventDefault(); handleTap(); }, {passive:false});

  startBtn.onclick = () => {
    if(State.phase==="running") return;
    startSequence();
  };

  resetBtn.onclick = () => resetAll();

  openResultsBtn.onclick = () => {
    if(!State.hasAnyData) return;
    if(State.phase === "finished" && !State.demo.submitted){
      openDemoSheet();
      return;
    }
    renderResults();
    results.classList.add("show");
  };

  closeResults.onclick = () => {
    results.classList.remove("show");
    hideTooltip();
  };

  renderChips(genderChips, GENDERS, (v)=>{
    State.demo.gender = v;
    setChipOn(genderChips, v);
    updateSubmitButton();
  });

  renderAgeSelect(5, 70);
  ageSelect.addEventListener("change", ()=>{
    State.demo.age = ageSelect.value;
    updateSubmitButton();
  });

  cancelDemo.onclick = ()=> closeDemoSheet();

  submitAndOpen.onclick = async ()=>{
    submitAndOpen.disabled = true;
    submitStatus.textContent = "제출 중…";
    submitStatus.className = "statusLine";

    try{
      const resp = await submitToServer();
      State.demo.submitted = true;
      State.demo.submitKey = resp.key || null;

      submitStatus.textContent = `제출 완료 ✅ (S3 key: ${resp.key || "unknown"})`;
      submitStatus.className = "statusLine ok";

      setTimeout(()=>{
        closeDemoSheet();
        renderResults();
        results.classList.add("show");
      }, 350);

    }catch(err){
      submitStatus.textContent = `제출 실패 ❌ (${err?.message || err})`;
      submitStatus.className = "statusLine bad";
      submitAndOpen.disabled = false;
    }
  };

  // =========================================================
  // Initial
  // =========================================================
  resetAll();

})();
</script>
</body>
</html>
